/**
 * First-tier k.LAB observation strategies. These are the leaves of the 
 * tree in the observation strategy, resolving using the literal concepts and matching the exact observable. 
 * They contain the obvious "observe" statements for their observables, but if the latter
 * depend on instantiatable collectives (like relationships) they will force the observation 
 * of their contextual dependents too.
 * 
 * The only predefined variable for the observable pattern are `$this`, substituted by the
 * observable being resolved, and  `$context` for the observable of the context observation. 
 * Any other should be extracted using `let` and an extractor
 * functor. `$this` is also the implicit argument of any functor invoked without 
 * arguments.
 */
strategies basic
	version 1.0;
	
strategy 0 named dependent.direct
  "As a first attempt, any concrete quality is just observed as it is."
   for imod:Quality if concrete, imod:Process if concrete
   observe $this of $context;

strategy 0 named countables.direct
   "Basic default strategy for any concrete collective countable except relationships: instantiate, then defer resolution of each 
    individual observation. This will match any predicates and operators since no restriction
    is specified on the observable."
   for each odo:Countable, !(each imod:Relationship) if concrete
   let observable = arity.single
   observe each $observable {
         resolve $observable optional
   };

strategy 0 named relationships.direct
   "Default strategy for relationship is equal to other countables but adds the resolution of target and source subjects"
   for each imod:Relationship if concrete
   let 
      source = relationship.source,
      target = relationship.target, 
      observable = arity.single
   resolve each $source
   resolve each $target
   observe each $observable {
      resolve $observable optional
   };
   
/*
 * Second-tier strategies will use "resolve" for partial resolutions and various merging strategies. 
 * These may fail while being completed and after causing observations to be made.
 */      
strategy 1 named countable.union
   "Countables in OR can be resolved in stages and merged"
   for odo:Countable or odo:Countable
   let first, second = split.operator
   resolve $first
   resolve $second
   apply klab.objects.merge($first, $second);

// next two should apply to booleans and categories   
strategy 1 named enumerable.quality.union
   "Types in OR can be resolved in stages and merged"
   for odo:EnumerableQuality or odo:EnumerableQuality
   let first, second = split.operator
   resolve $first
   resolve $second
   apply klab.types.union($first, $second);
   
strategy 1 named enumerable.quality.intersection
   "Types in AND: split first operand, resolve operand and reminder, then merge qualities"
   for odo:EnumerableQuality and odo:EnumerableQuality
   let first, second = split.operator
   resolve $first
   resolve $second
   apply klab.types.intersection($first, $second);

/**
 * For countables with concrete predicates: separate `@Observable` and `@Predicate`, 
 * resolve `@Observable`, then if successful resolve `@Predicate of each @Observable` using collective 
 * characterization. If that also fails, try resolving `@Predicate of @Observable` for each 
 * individual countable.
 */   
strategy 1 named countables.split.predicate
   "Split the first predicate, instantiate remainder, then classify"
   for each odo:Countable if count.predicates > 0
   let observable, predicate = split.predicate, baseobservable = base.observable(this:Predicate)
   ensure concrete(this:Predicate)
   resolve $predicate of each $observable
   apply klab.object.filter($observable, $predicate)
   resolve each $observable {
      resolve $predicate of $observable
   }, {
      resolve $baseobservable of $observable
   };
